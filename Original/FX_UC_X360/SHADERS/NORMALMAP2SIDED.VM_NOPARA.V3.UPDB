<?xml version="1.0" encoding="utf-8"?>
<shader-pdb pdbHint="4e4a0000-27587e36-fa652e26" version="6995">
 <files>
  <file id="0" path="C:\D1017315-LeigpzigDemo\MW2\Branches\LeipzigDemo\Speed\Indep\Src\Render\effects\normalmap2sided.bbfx" time="01c8f9c0-c77698b6">/********************************************************************
	file:		mw2_normalmap2sided.bbfx

	purpose:	general purpose shader using normal and specular maps

*********************************************************************/

#define SPECULAR	  
#if defined(SHADERMODEL_3_0)
#define NORMALMAP	  
#endif

#include "mw2_normalmap_refl.h"

//--------------------------------------------------------------------------------------
// BBFX Declarations
//--------------------------------------------------------------------------------------

/*
Usage Information: This is used by the pipe, and by MAX
STARTUSAGE: 
materialDescription: This is a 2 sided normalmap, specular mask material.
isTranslucent: false
texture: TEXCOORD0, MAP1, diffuse, DIFFUSE_SAMPLER, "diffuse map", "Location8/content/Maps/DFT/DFT_Diffuse_01_D.tga" 
texture: TEXCOORD0, MAP1, specular, SPECULAR_SAMPLER, "specular mask", "Location8/content/Maps/DFT/DFT_White_01.psd"
texture: TEXCOORD0, MAP1, normal, NORMALMAP_SAMPLER, "normal map", "Location8/content/Maps/DFT/DFT_Normal_01_N.tga"
PLATFORM: XENON
stream0: POSITION0, float4
stream0: COLOR0, color
stream0: TEXCOORD0, half2
stream0: NORMAL0, dec4n
stream0: TANGENT0, dec4n
PLATFORM: PS3
stream0: POSITION0, float4
stream0: COLOR0, color
stream0: TEXCOORD0, half2
stream0: NORMAL0, cmp3n
stream0: TANGENT0, cmp3n
PLATFORM: PC
stream0: POSITION0, float4
stream0: COLOR0, color
stream0: TEXCOORD0, short2n_32x
stream0: NORMAL0, short4n
stream0: TANGENT0, short4n
ENDUSAGE
*/

const string MaterialClass = "Default";

technique mw2_normalmap_default
&lt;
	string viewtag = "ANY";
	string lostag = "ANY";
&gt;
{
    pass P0 
	&lt; 
		string depthstencil = "default"; 
		string blend = "default"; 
		string rasterizer = "double_sided"; 
	&gt;
    {   
        VertexShader = compile vs_3_0 VM_NoPara();
        PixelShader  = compile ps_3_0 PixelMain();
    }
}

// For rendering *into* a paraboloid reflection map
technique mw2_normalmap_parabolicenvironmentview
&lt;
	string viewtag = "ENVMAP_PARABOLOID";
	string lostag = "ANY";
&gt;
{
    pass P0 
	&lt; 
		string depthstencil = "default"; 
		string blend = "default"; 
		string rasterizer = "double_sided"; 
	&gt;
    {   
        VertexShader = compile vs_3_0 VM_Para();
        PixelShader  = compile ps_3_0 PM_NoRefl();
    }
}

// For rendering *into* a reflection map
technique mw2_normalmap_environmentview
&lt;
	string viewtag = "ENVMAP";
	string lostag = "ANY";
&gt;
{
    pass P0 
	&lt; 
		string depthstencil = "default"; 
		string blend = "default"; 
		string rasterizer = "double_sided"; 
	&gt;
    {   
        VertexShader = compile vs_3_0 VM_NoPara();
        PixelShader  = compile ps_3_0 PM_NoRefl();
    }
}

#include "mw2_shadow_csm.h"


#ifdef PLAT_PS3
#include "mw2_zprep.h"
#endif
</file>
  <file id="1" path="C:\D1017315-LeigpzigDemo\MW2\Branches\LeipzigDemo\Speed\Indep\Src\Render\effects\common\mw2_normalmap_refl.h" time="01c8f9c0-c76d0f4e">/********************************************************************
	file:		mw2_normalmap_refl.h

	purpose:	include file for general purpose shader using normal and specular maps

*********************************************************************/
/*
1.) To enable the brightness you need to set twk_CarGuysUseBrightnessContrast to true (under Car in Ritalin).

2.) For World brightness - WorldBrightnessInEnvMapInGame (float)

3.) For Sky brightness - SkyBrightnessEnvMap (float)
*/

#ifndef MW2_NORMALMAP_REFL_H
#define MW2_NORMALMAP_REFL_H

//--------------------------------------------------------------------------------------
// Includes
//--------------------------------------------------------------------------------------
#include "global.h"
#include "gamma.h"
#include "mw2_lighting_models.h"

#include "shadowmap_fx_def.h"
#include "hdr.h"

//--------------------------------------------------------------------------------------
// Global Parameters
//--------------------------------------------------------------------------------------

float4		cvWorldSunColour		: REG_cvWorldSunColour;		
float4		cvWorldAmbientColour	: REG_cvWorldAmbientColour;	
float4		cvWorldSpecularColour	: REG_cvWorldSpecularColour;		

//--------------------------------------------------------------------------------------
// Material Parameters - Attribulator
//--------------------------------------------------------------------------------------

float	ambient_intensity;
float	ambient_occlusion_bias;
float	diffuse_intensity;
float	specular_intensity;		

float	specular_power;		
#ifdef REFLECT
float	reflection_intensity;
float	reflection_shadow_intensity;		
//float	reflection_static_rotate_azimuth;		
float	reflection_static_rotate_elevation;		
float	reflection_vert_scale;		
#endif
#ifdef SHADERBLEND
float	lod_blend_begin;
float	lod_blend_bias;
#endif

//float	debug_normal_scale;

//--------------------------------------------------------------------------------------
// Functions
//--------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------
// Input and Output Structures
//--------------------------------------------------------------------------------------

struct VS_INPUT
{
	float4 Position			: POSITION0; 
	float4 Color			: COLOR0;
	float2 TexCoord			: TEXCOORD0;
	float4 Normal			: NORMAL0;
	float4 Tangent			: TANGENT0;	
};

struct VtoP
{
	float4 Position			: POSITION;
	float3 TexCoord_AO		: TEXCOORD0;	// xy = diffuse uv's,	z = ambient occlusion
	float4 Normal			: TEXCOORD1;
	float4 PositionObject	: TEXCOORD2;
#ifdef NORMALMAP
	float4 Tangent			: TEXCOORD3;
#endif
#ifdef REFLECT
	float4 viewRotn			: TEXCOORD4;
#endif
	float4 ShadowTex		: TEXCOORD5;
#ifdef SHADERBLEND
	float4 LODLighting		: TEXCOORD6;
#endif
};

//--------------------------------------------------------------------------------------
/// Samplers
//--------------------------------------------------------------------------------------

sampler2D DIFFUSE_SAMPLER 
&lt;
	string TextureSamplerState = "DIFFUSE_SAMPLER";		// as specified in attribulator
&gt;;


sampler2D SPECULAR_SAMPLER 
&lt;	
	string TextureSamplerState = "MASK_SAMPLER";
&gt;;

#ifdef NORMALMAP
sampler2D NORMALMAP_SAMPLER 
&lt;
	string TextureSamplerState = "NORMALMAP_SAMPLER";
&gt;;
#endif

#ifdef REFLECT
sampler2D REFLECTION_SAMPLER // this will be channel packed out later
&lt;
	string TextureSamplerState = "REFLECTION_SAMPLER";
&gt;;
#endif


//--------------------------------------------------------------------------------------
// Vertex Shader
//--------------------------------------------------------------------------------------
VtoP VertexMain(const VS_INPUT IN, COMPILETIME_BOOL enableParaboloidBasis)
{
	VtoP OUT;

	//
	// World View Projection position
	//
	float4 position			= world_position( enableParaboloidBasis, IN.Position );
	OUT.Position			= position;

	OUT.PositionObject		= IN.Position;

#if defined(SHADERMODEL_3_0)
	OUT.TexCoord_AO.z		= bias(ambient_occlusion_bias,IN.Color.x)*2;
#else
	OUT.TexCoord_AO.z		= 1;
#endif

	OUT.TexCoord_AO.xy		= DeCompressTextCoords(IN.TexCoord.xy);
#ifdef NORMALMAP
	OUT.Tangent				= IN.Tangent;
#endif
                          //$$TODO: NormalTransform needs to know if we are instance-rendering
	OUT.Normal.xyz			= IN.Normal.xyz;//NormalTransform(IN.Normal.xyz);
    OUT.Normal.w=1;

#ifdef SHADERBLEND
	// blend to low lod shader
	float  shaderBlend		= length(view)/(300*lod_blend_begin);
	shaderBlend				= bias(lod_blend_bias,shaderBlend);
	OUT.LODLighting.w		= saturate(shaderBlend);

	float3 lightDir			= normalize(cvLocalLightVec.xyz);
	float ndotL				= dot(IN.normal.xyz, lightDir);
	float3 diffuse			= saturate(ndotL) * cvWorldSunColour.xyz;
	OUT.LODLighting.xyz		= diffuse + cvWorldAmbientColour.xyz;
#endif

	OUT.ShadowTex			= VertexShadowTex( IN.Position, false );

#ifdef REFLECT
	float4 viewObj			= normalize(cvLocalEyePos - IN.Position); 
	// rotate static map around z vector because we don't know how to make maps from max
	//float rotRad			= radians(reflection_static_rotate_azimuth  * 360);
	//float newX				= cos(rotRad)* viewObj.x - sin(rotRad) * viewObj.y;
	//float newY				= sin(rotRad)* viewObj.x + cos(rotRad) * viewObj.y;
	float4 rotView			= normalize(float4(viewObj.xy, (viewObj.z + reflection_static_rotate_elevation)*reflection_vert_scale,viewObj.w));
	OUT.viewRotn			= rotView;
#endif

	return OUT;
}

// bbfx parser does not support passing params at the top level so we work around with pre-made functions
VtoP VM_NoPara(const VS_INPUT IN)
{
	return VertexMain(IN, PARABOLOIDBASIS_FALSE);
}

// bbfx parser does not support passing params at the top level so we work around with pre-made functions
VtoP VM_Para(const VS_INPUT IN)
{
	return VertexMain(IN, PARABOLOIDBASIS_TRUE);
}

//--------------------------------------------------------------------------------------
// Pixel Shader
//--------------------------------------------------------------------------------------

float4 PixelMain(const VtoP IN) : COLOR
{
	float4 OUT				= 1;	
	float ambientOcclusion	= IN.TexCoord_AO.z; 

#ifdef SHADERBLEND
	float shaderBlend		= IN.LODLighting.w;
#endif

#ifdef NORMALMAP
	// Need This To Use Normal For Local Lighting\Reflection\Etc...
	float3x3 norm_obj_to_tangent_trans;
	norm_obj_to_tangent_trans[0] = normalize( IN.Tangent.xyz );
	norm_obj_to_tangent_trans[2] = normalize( IN.Normal.xyz );
	norm_obj_to_tangent_trans[1] = cross( norm_obj_to_tangent_trans[2], norm_obj_to_tangent_trans[0] ) * IN.Tangent.w;	
#endif	
	// Sun Direction In World Space
	float3 sunDirWorld		= normalize( mul( ( float3x3 )cmWorldMatTranspose, cvLocalLightVec.xyz ).xyz );

	float2 tex				= IN.TexCoord_AO.xy;
	
	// Get All Maps
	float4 base				= float4(0.5, 0.5, 0.5, 1);
	float specMask			= 0.5;

	base					= tex2D( DIFFUSE_SAMPLER, tex.xy ); //diffuse map	
	base.rgb				= GammaExpand( base.rgb );

	specMask				= tex2D( SPECULAR_SAMPLER, tex.xy ).x;

	float3 normal			= IN.Normal.xyz;
#ifdef NORMALMAP	  
	normal					= tex2D( NORMALMAP_SAMPLER, tex.xy ).xyz;

#ifndef PLAT_XENON
	// Convert between unsigned and signed normal map data (TraditionalRGB)
	normal.xyz				= ( normal.xyz - 0.5 ) * 2;
#else
	// Convert between unsigned and signed normal map data (DXN)
	normal.xy				= ( normal.xy - 0.5 ) * 2;
	normal.z				= sqrt( 1 - dot( normal.xy, normal.xy ) );
#endif

	//
	// Place normal in object space (tangent-&gt;object)
	//
	normal.xyz				= mul( normal.xyz, norm_obj_to_tangent_trans );
#endif

	//
	// Place normal in world space (object-&gt;world)
	//
	normal.xyz				= mul( ( float3x3 ) cmWorldMatTranspose, normal.xyz ).xyz;
	//normal.xyz				= float3(normal.x, normal.y, normal.z * debug_normal_scale);
	normal.xyz				= normalize( normal.xyz );

#ifdef REFLECT
	float reflMask			= tex2D( REFLECTION_SAMPLER, tex.xy ).y; 
#endif

	// world position and view direction in world space
	float4 viewObj			= cvLocalEyePos - IN.PositionObject ; 
	float3 viewWorld		= normalize(mul(viewObj, cmWorldMat)).xyz; // Don't do this in the VS. It makes the specular only move with verts not pixels

	// Calculate Base Diffuse and Specular Lighting Before Shadow....
	float nDotL				= dot( normalize( normal.xyz ), sunDirWorld );
	float diffuse			= saturate(nDotL);
	diffuse					*= diffuse_intensity;

	// Calc Shadow
	float shadow			= saturate(DoShadowOptimized( IN.ShadowTex, nDotL, 0 )/7);

	// Do final lighting 
	float3 ambient			= ambient_intensity * cvWorldAmbientColour.xyz;
	OUT.xyz					= BasicAOLightingModel( diffuse, shadow, base.rgb, ambientOcclusion, ambient, cvWorldSunColour.xyz );

#ifdef SPECULAR
	float3 spec				= BlinnSpec( viewWorld, sunDirWorld, normal.xyz, specular_power );
	spec					*= specular_intensity;	
	spec					*= specMask;	
	//spec					*= saturate( cvWorldSpecularColour.xyz );	// taking this out.  must have been in at one time due to bug
	spec					*= cvWorldSpecularColour.xyz ;	
	spec					*= ambientOcclusion;	
	spec					*= shadow;	// buggy
	OUT.xyz					+= ( 1.0 - OUT.xyz ) * spec ; // Avoid specular saturation around hot edges....
#endif	

#ifdef REFLECT
	viewObj					= IN.viewRotn ; // use the scaled and offset z for reflection
	viewWorld				= normalize(mul(viewObj, cmWorldMat)).xyz; 
	float3 reflVector		= reflect(-viewWorld, normal.xyz);

	float4 envMapSampler;

	envMapSampler			= EnvironmentMapLookup_Building(reflVector);

	envMapSampler.xyz		= DeCompressColourSpace(envMapSampler.xyz);  //reenable for when it comes from the reflection
   // envMapSampler.xyz       = HdrExpand(float4(envMapSampler.xyz,envMapSampler.x));
    envMapSampler.xyz		= GammaExpand(envMapSampler.xyz);

	float3 env				= envMapSampler.xyz * reflMask;		 
	env						*= saturate(diffuse + valueOf(cvWorldAmbientColour.xyz)/2);
	env						= lerp(env * reflection_shadow_intensity, env * reflection_intensity, saturate(shadow)) ;  
	env						*= base.rgb/valueOf(base.xyz);
	OUT.xyz					+= env ; 
#endif

#ifdef SHADERBLEND
	OUT.xyz					= OUT.xyz + 0.00001 * mix(OUT.xyz, IN.LODLighting * base.xyz, shaderBlend);  
#endif

	// Shader Test
	//OUT.xyz = OUT.xyz * 0.00001 + abs(frac(float3(tex.xy,1)));
	//OUT.xyz = OUT.xyz * 0.00001 + base.xyz;
	//OUT.xyz = OUT.xyz * 0.00001 + env;
	//OUT.xyz = OUT.xyz * 0.00001 + BlinnSpec( viewWorld, sunDirWorld, normal.xyz, specular_power );
	//OUT.xyz = OUT.xyz * 0.00001 + BasicAOLightingModel( diffuse, shadow, base.rgb, ambientOcclusion, ambient, cvWorldSunColour.xyz );
	//OUT.xyz = OUT.xyz * 0.00001 + BasicAOLightingModel( diffuse, shadow, float3(0.5, 0.5, 0.5), ambientOcclusion, ambient, cvWorldSunColour.xyz );
	//OUT.xyz = OUT.xyz * 0.00001 + diffuse;
	//OUT.xyz = OUT.xyz * 0.00001 + shadow /2;
	//OUT.xyz = OUT.xyz * 0.00001 + base.xyz;
	//OUT.xyz = OUT.xyz * 0.00001 + ambientOcclusion*(1-shadow);
	//OUT.xyz = OUT.xyz * 0.00001 + ambientOcclusion;
	//OUT.xyz = OUT.xyz * 0.00001 + ambient;
	//OUT.xyz = OUT.xyz * 0.00001 + cvWorldSunColour.xyz ;
	//OUT.xyz = OUT.xyz * 0.00001 + abs(IN.normal.xyz); // stays stable and as expected
	//OUT.xyz = OUT.xyz * 0.00001 + abs(normal.xyz);  //dynamic random values
	//float4 localPos		= IN.PositionObject;
	//float4 localEye		= cvLocalEyePos;
	//float4 worldEye		=  mul(localEye, cmWorldMat); 
	//float4 view_obj		= cvLocalEyePos - localPos ; 
	//float3 view_world	= OUT.xyz * 0.00001 + mul(view_obj, cmWorldMat).xyz; 
	//OUT.xyz				= OUT.xyz * 0.00001 + float3(0.5, 0.5, 0.5) + (normalize( IN.ViewWorld) / 2);
	//OUT.xyz = OUT.xyz * 0.00001 + saturate(normalize( IN.ViewWorld.xyz ));
	
#ifdef SPECULAR
	//OUT.xyz = OUT.xyz * 0.00001 + spec;
	//OUT.xyz = OUT.xyz * 0.00001 + specMask;
	//OUT.xyz = OUT.xyz * 0.00001 + diffuse_intensity;
	//OUT.xyz = OUT.xyz * 0.00001 + specular_intensity;
#endif
	//OUT.xyz = OUT.xyz * 0.00001 + float3(1,0,0);
	//OUT.xyz = OUT.xyz * 0.00001 + diffuse_intensity;
	//OUT.xyz = OUT.xyz * 0.00001 + diffuse + cvWorldAmbientColour.xyz;
	//OUT.xyz = OUT.xyz * 0.00001 + cvWorldAmbientColour.xyz;
	//OUT.xyz = OUT.xyz * 0.00001 + cvWorldSunColour.xyz;
	//OUT.xyz = OUT.xyz * 0.000000001 + specular_intensity/10;
	//OUT.xyz = OUT.xyz * 0.00001 + specular_power/100;
	//OUT.xyz = OUT.xyz * 0.00001 + abs(normalize(sunDirWorld));  //this has a mat mult of cvLocalLightVec and seems ok
	//OUT.xyz = OUT.xyz * 0.00001 + normalize(cvLocalLightVec.xyz);  // actually looks ok
	//OUT.xyz = OUT.xyz * 0.00001 + cvWorldSunColour.xyz;          //seems overbright by 2
	//OUT.xyz = OUT.xyz * 0.00001 + bias(.3,shaderBlend);  
	//OUT.xyz = OUT.xyz * 0.00001 + mix(base.xyz, float3(1,0,1),shaderBlend);      // debug Matt
	//OUT.xyz = OUT.xyz * 0.00001 + base.rgb/saturation(base.xyz);     
#ifdef REFLECT
	//OUT.xyz = OUT.xyz * 0.00001 + reflection_intensity;
	//OUT.xyz = OUT.xyz * 0.00001 + env.rgb;
	//OUT.xyz = OUT.xyz * 0.00001 + env.rgb * base.rgb/saturation(base.xyz);
#if defined(ENVMAP_TESTING)
	OUT.xyz = OUT.xyz * 0.00001 + envMapSampler.xyz;
	//OUT.xyz *= reflection_intensity;
#endif
	//OUT.xyz = OUT.xyz * 0.00001 + float3(1,0,1);
	//OUT.xyz = OUT.xyz * 0.00001 + reflMask;
	//OUT.xyz = OUT.xyz * 0.00001 + (IN.viewRotn + float3(1,1,1))/2;
	//OUT.xyz = OUT.xyz * 0.00001 + (reflVector + float3(1,1,1))/2;
#endif

	//OUT.xyz = float3(1,0,1);
	//
	// linear to log
	//
	OUT.xyz					= GammaCompress(OUT.xyz);

	//
	// Out to HDR Buffer...
	//
	OUT.xyz					= CompressColourSpace( OUT.xyz );

	return OUT;
}

float4 PixelShaderNoReflection(const VtoP IN)
{
	float4 OUT				= 1;	
	float ambientOcclusion	= IN.TexCoord_AO.z; 

#ifdef SHADERBLEND
	float shaderBlend		= IN.LODLighting.w;
#endif

#ifdef NORMALMAP
	// Need This To Use Normal For Local Lighting\Reflection\Etc...
	float3x3 norm_obj_to_tangent_trans;
	norm_obj_to_tangent_trans[0] = normalize( IN.Tangent.xyz );
	norm_obj_to_tangent_trans[2] = normalize( IN.Normal.xyz );
	norm_obj_to_tangent_trans[1] = cross( norm_obj_to_tangent_trans[2], norm_obj_to_tangent_trans[0] ) * IN.Tangent.w;	
#endif
	// Sun Direction In World Space
	float3 sunDirWorld		= normalize( mul( ( float3x3 )cmWorldMatTranspose, cvLocalLightVec.xyz ).xyz );

	float2 tex				= IN.TexCoord_AO.xy;


	// Get All Maps
	float3 base				= float3(0.5, 0.5, 0.5);
	float specMask			= 0.5;

	base					= tex2D( DIFFUSE_SAMPLER, tex.xy ).rgb; //diffuse map	
	base.rgb				= GammaExpand( base.rgb );

	specMask				= tex2D( SPECULAR_SAMPLER, tex.xy ).x;

	float3 normal			= IN.Normal.xyz;
#ifdef NORMALMAP	  
	normal					= tex2D( NORMALMAP_SAMPLER, tex.xy ).xyz;

#ifndef PLAT_XENON
	// Convert between unsigned and signed normal map data (TraditionalRGB)
	normal.xyz				= ( normal.xyz - 0.5 ) * 2;
#else
	// Convert between unsigned and signed normal map data (DXN)
	normal.xy				= ( normal.xy - 0.5 ) * 2;
	normal.z				= sqrt( 1 - dot( normal.xy, normal.xy ) );
#endif

	//
	// Place normal in object space (tangent-&gt;object)
	//
	normal.xyz				= mul( normal.xyz, norm_obj_to_tangent_trans );
#endif

	//
	// Place normal in world space (object-&gt;world)
	//
	normal.xyz				= mul( ( float3x3 ) cmWorldMatTranspose, normal.xyz ).xyz;
	normal.xyz				= normalize( normal.xyz );

	// world position and view direction in world space
	float4 viewObj			= cvLocalEyePos - IN.PositionObject ; 
	float3 viewWorld		= normalize(mul(viewObj, cmWorldMat)).xyz; 

	float3 reflVector		= reflect(-viewWorld, normal.xyz);


	// Calculate Base Diffuse and Specular Lighting Before Shadow....
	float nDotL				= dot( normalize( normal.xyz ), sunDirWorld );
	float diffuse			= saturate(nDotL);

	// Calc Shadow
	float shadow			= DoShadowOptimized( IN.ShadowTex, nDotL, 0 )/5;

	// Do final lighting 
	float3 ambient			= ambient_intensity * cvWorldAmbientColour.xyz;
	diffuse					*= diffuse_intensity;
	OUT.xyz					= BasicAOLightingModel( diffuse, shadow, base.rgb, ambientOcclusion,ambient, cvWorldSunColour.xyz );

#ifdef SPECULAR
	float3 spec				= BlinnSpec( viewWorld, sunDirWorld, normal.xyz, specular_power );
	spec					*= specMask * specular_intensity;	
	spec					*= saturate( cvWorldSpecularColour.xyz );	
	spec					*= ambientOcclusion;	
	spec					*= shadow;	
	OUT.xyz					+= ( 1.0 - OUT.xyz ) * spec ; // Avoid specular saturation around hot edges....
#endif	

#ifdef SHADERBLEND
	OUT.xyz					= OUT.xyz + 0.00001 * mix(OUT.xyz, IN.LODLighting * base.xyz, shaderBlend);  
#endif

	//
	// Brightness control for world/sky env reflection
	//
	OUT.xyz					*= cvVertexPowerBrightness.y;

	//OUT.xyz = OUT.xyz * 0.00001 + ambient;
	//OUT.xyz = OUT.xyz * 0.00001 + diffuse;
	//OUT.xyz = OUT.xyz * 0.00001 + float3(1,1,0);
	//OUT.xyz = OUT.xyz * 0.00001 + spec;
	//OUT.xyz = OUT.xyz * 0.00001 + specMask;
	//OUT.xyz = OUT.xyz * 0.00001 + BasicAOLightingModel( diffuse, shadow, base.rgb, ambientOcclusion,ambient, cvWorldSunColour.xyz );
	//OUT.xyz = OUT.xyz * 0.00001 + cvWorldSunColour.xyz;
	//OUT.xyz = OUT.xyz * 0.00001 + float3(0,1,0);
	//OUT.xyz = float3(0,0,1);

	//
	// linear to log
	//
	OUT.xyz					= GammaCompress(OUT.xyz);

	//
	// Out to HDR Buffer...
	//
	OUT.xyz					= CompressColourSpace( OUT.xyz );

	return OUT;
}

float4 PM_NoRefl(const VtoP IN) : COLOR0
{
	return PixelShaderNoReflection(IN);
}

#endif
</file>
  <file id="2" path="C:\D1017315-LeigpzigDemo\MW2\Branches\LeipzigDemo\Speed\Xenon\Src\Render\effects\global.h" time="01c8f9c5-4d521c5e">#ifndef GLOBAL_H
#define GLOBAL_H

#include "registermap.h"   
#include "global_common.h"

// Defined out for the Xbox360 - only needed on the PC
#define DECLARE_TEXTURE(texture)	
#define ASSIGN_TEXTURE(texture)	
#define DECLARE_MINFILTER(default_filter)			 MINFILTER = default_filter;
#define DECLARE_MAGFILTER(default_filter)			 MAGFILTER = default_filter;
#define DECLARE_MIPFILTER(default_filter)			 MIPFILTER = default_filter;

#ifndef SHADERMODEL_3_0
    #define SHADERMODEL_3_0
#endif

/////////////////////////////////////////////////////////////////////////////////////////

//--------------------------------------------------------------------------------------
// Global Parameters - platform specific.
//--------------------------------------------------------------------------------------
float4		cvScreenOffset			: REG_cvScreenOffset;
float4		cvVertexPowerBrightness : REG_cvVertexPowerBrightness;

#include "reflection.h"

float4 world_cartesian_position( float4 screen_pos )
{
 	float4 p = mul(screen_pos, cmWorldViewProj);  
    return p;
}

float4 world_position(COMPILETIME_BOOL enableParaboloidBasis, float4 modelspace_position)
{
	if (enableParaboloidBasis)
	{
		return world_paraboloid_position(modelspace_position);
	}
	else
	{
		return world_cartesian_position(modelspace_position);
	}
}

float4 world_position(float4 modelspace_position, COMPILETIME_BOOL enableParaboloidBasis, COMPILETIME_BOOL instanceRender)
{
	if(instanceRender)
	{
		// Want to do a compile time assert here as Instance rendering isn't supported on Xenon at the moment.
	}

	if (enableParaboloidBasis)
	{
		return world_paraboloid_position(modelspace_position);
	}
	else
	{
		return world_cartesian_position(modelspace_position);
	}
}

/////////////////////////////////////////////////////////////////////////////////////////
// HDR Colour Space compression
/////////////////////////////////////////////////////////////////////////////////////////

/* 
This function maps input 'c' to a curve. 

It is a really important curve!
It provides the following transformation on the input color:

1. Compresses the dynamic range from 0-2 to 0-1 (which is expressable in 8 bits)
2. Adds a 'filmic' shoulder to the high end that prevents the color from "slamming
into the ceiling", which is a class digital problem with a limited number of bits.

Jim Hejl
07/12/2008
*/
float3 CompressColourSpace(float3 c)
{
    // filmic response, without implicit gamma
    // GammaCompress() is active, and does a sqrt() after this response curve
    return (1-(pow(1-(c*.5),2)));
    /*
    float3 c0, c1;
    c0 = max(c*.75,1);
    c1 = min(1,c*.75);
    c1 = 1-pow(c1,2);

    return (c0-c1)*1.3333; 
    */

    //return (c*.5);//(c*0.5);//saturate((c/(c+0.1812))*1.0906); 
} 

float3 DeCompressColourSpace(float3 c)
{
    // no curve removal at this time
    return (c);
    
    //(c*2);//(c/((1-c)+0.1))*0.2;
}

half2 DeCompressTextCoords(half2 textCoords)
{
	return textCoords;
}

/////////////////////////////////////////////////////////////////////////////////////////
// RGBE8 Encoding/Decoding
// The RGBE8 format stores a mantissa per color channel and a shared exponent 
// stored in alpha. Since the exponent is shared, it's computed based on the
// highest intensity color component. The resulting color is RGB * 2^Alpha,
// which scales the data across a logarithmic scale.
/////////////////////////////////////////////////////////////////////////////////////////

float4 EncodeRGBE8( in float3 rgb )	  
{
	float4 vEncoded;

    // Determine the largest color component
	float maxComponent = max( max(rgb.r, rgb.g), rgb.b );
	
	// Round to the nearest integer exponent
	float fExp = ceil( log2(maxComponent) );

    // Divide the components by the shared exponent
	vEncoded.rgb = rgb / exp2(fExp);
	
	// Store the shared exponent in the alpha channel
	vEncoded.a = (fExp + 128) / 255;

	return vEncoded;
}

/////////////////////////////////////////////////////////////////////////////////////////

float3 DecodeRGBE8( in float4 rgbe )
{
	float3 vDecoded;

    // Retrieve the shared exponent
	float fExp = rgbe.a * 255 - 128;
	
	// Multiply through the color components
	vDecoded = rgbe.rgb * exp2(fExp);
	
	return vDecoded;
}

/////////////////////////////////////////////////////////////////////////////////////////
#endif
</file>
  <file id="3" path="C:\D1017315-LeigpzigDemo\MW2\Branches\LeipzigDemo\Speed\Xenon\Src\Render\effects\registermap.h" time="01c8f9c5-4d521c5e">
// ------------------------------------------------------------------------------------------------------------------------------------------

#define CONSTANT_RESERVED_DO_NOT_USE			(0)		/* 4 vectors [c0,c3] */

// ------------------------------------------------------------------------------------------------------------------------------------------

#define REG_RESERVED_DO_NOT_USE				register(c0)	/* 4 vectors [c0,c3] */

#define REG_cmWorldMat						register(c4)	/* 4 vectors [c0,c3] */
#define REG_cmWorldMatTranspose				register(c8)	/* 4 vectors [c4,c7] */
#define REG_cmWorldView						register(c12)	/* 4 vectors [c8,c11] */
#define REG_cmShadowMapWVP					register(c16)	/* 4 vectors [c12,c15] */
#define REG_cmLightWVP						register(c20)	/* 4 vectors [c16,c19] */
#define REG_cmWorldViewProj					register(c24)	/* 4 vectors [c20,c23] */
#define REG_cmPrevWorldViewProj				register(c28)	/* 4 vectors [c24,c27] */
#define REG_cvLocalEyePos					register(c32)	/* 1 vecotr	 [c32] */
#define REG_cvLocalLightVec					register(c33)	/* 1 vecotr	 [c33] */
#define REG_cfSkyDomeRotation				register(c34)	/* 1 vecotr	 [c34] */

#define REG_cmLocalColourMatrix				register(c36)	/* 4 vectors [c36,c39] */
#define REG_cmLocalDirectionMatrix			register(c40)	/* 4 vectors [c40,c43] */
#define REG_cmLocalPositionMatrix			register(c44)	/* 4 vectors [c44,c47] */
#define REG_cavHarmonicCoeff				register(c48)	/* 10 floats, 3 vectors, 1 pad vector [48,51] */

#define REG_cvWorldSpecularColour			register(c49)
#define REG_cvWorldSunColour				register(c50)
#define REG_cvWorldAmbientColour			register(c51)

#define REG_camBlendMatrices				register(c52)	/* 64 vectors [c52,c115] */
#define REG_cavWorldHeadlightDirection		register(c68)	/* 2 vectors [c68,c69] */
#define REG_cavWorldHeadlightPosition		register(c70)	/* 2 vectors [c70,c71] */
#define REG_cavWorldHeadlightUpDirection	register(c72)	/* 2 vectors [c72,c73] */

#define REG_cvSHColour						register(c51)

// available: [c82,c115] (but would alias cavPcaWeightsR and cavPcaWeightsG)
// PCA/UCap parameters (ucap.fx, water.fx)
#define REG_cafPcaMean					register(c81)	/* 1 vector */
#define REG_cavPcaWeightsR				register(c82)	/* 22 vectors [c82,c103] */
#define REG_cavPcaWeightsG				register(c104)	/* 22 vectors [c104,c125] */
#define REG_cavPcaWeightsB				register(c126)	/* 22 vectors [c126,c147] */
#define REG_cavPcaWeightsX				register(c148)	/* 8 vectors [c148,c155] */
#define REG_cavPcaWeightsY				register(c156)	/* 8 vectors [c156,c163] */
#define REG_cavPcaWeightsZ				register(c164)	/* 8 vectors [c164,c171] */
#define REG_cavPcaWeightsNX				register(c172)	/* 8 vectors [c172,c179] */
#define REG_cavPcaWeightsNY				register(c180)	/* 8 vectors [c180,c187] */
#define REG_cavPcaWeightsNZ				register(c188)	/* 8 vectors [c188,c195] */
#define REG_cavFeatureHeights			register(c196)	/* 1 vector */

// The following parameters alias cavPcaWeightsG:
#define REG_cfMipMapBias				register(c116)
#define REG_cfBrightness				register(c117)
#define REG_cfSurfaceReflection			register(c118)
#define REG_cfRainIntensity				register(c119)
#define REG_cfSpecularPower				register(c120)
#define REG_cfMetallicScale				register(c121)
#define REG_cfEnvmapPullAmount			register(c122)
#define REG_cfEnvmapPower				register(c123)
#define REG_PAD2						register(c125)

// The following parameters alias cavPcaWeightsB:
#define REG_cfCombinedBrightness		register(c126)
#define REG_cvVisualEffectFadeColour	register(c127)	/* also aliases cfSkyAlphaTag */
#define REG_cfSkyAlphaTag				register(c127)	/* also aliases cvVisualEffectFadeColour */
#define REG_cfShadowVolumeOffset		register(c128)
#define REG_cfRVMWorldBrightness		register(c129)
#define REG_cfDesaturation				register(c130)
#define REG_cfSplitScreenUVScale		register(c132)
#define REG_cfColourCubeFilterBlend		register(c133)
#define REG_cfTimeTicker				register(c134)
#define REG_cfMiddleGray				register(c135)
#define REG_cfBrightPassThreshold		register(c136)
#ifndef SMOKE_XENON
#define REG_cvScreenOffset				register(c137)
#else
#define REG_cvScreenOffset				register(c63)
#endif
#define REG_cvFog_Br_Plus_Bm			register(c138)
#define REG_cvFog_One_Over_BrBm			register(c139)
#define REG_cvFog_Const_1				register(c140)
#define REG_cvFog_Const_2				register(c141)
#define REG_cvFog_Const_3				register(c142)
#define REG_cvAmbientColour				register(c143)
#define REG_cvShadowParams0				register(c144)
#define REG_cvShadowParams1				register(c145)

// The following parameters alias cavPcaWeightsX:
#define REG_cvDiffuseColour				register(c148)
#define REG_cvSpecularColour			register(c149)
// available: [c150,c155] (but would alias cavPcaWeightsX)

// The following parameters alias cavPcaWeightsY:
#define REG_cvShadowColour				register(c156)
#define REG_cvTextureOffset				register(c161)
#define REG_cvLocalCenter				register(c162)
#define REG_cvTreeParams				register(c163)

// The following parameters alias cavPcaWeightsZ:
#define REG_cvBaseAlphaRef				register(c164)
#define REG_cvCloudIntensity			register(c165)
#define REG_cvLocalLightPos				register(c166)
#define REG_cvPixelizationScale			register(c167)
#define REG_cvGrassColour				register(c169)

// The following parameters alias cavPcaWeightsNX:
#define REG_cvDepthOfFieldParams		register(c172)	/* aliases cavFeatureHeights */
#define REG_cvBlurParams				register(c173)

// The following parameters alias cavPcaWeightsNX and cavPcaWeightsNY:
#define REG_cavSampleOffsetWeights		register(c174)	// 16 vectors
#define REG_cvSmokeParams				register(c175)
#define REG_cmShadowMapVP				register(c180)	// 4 vectors
#define REG_cmShadowMapBiasMatrix		register(c184)	// 4 vectors
#ifndef SMOKE_XENON
#define REG_cmCSMTransform				register(c188)	// 4 vectors
#else
#define REG_cmCSMTransform				register(c50)	// 4 vectors
#endif
#define REG_cvTint						register(c190)
#define REG_PAD0						register(c191)	/* free space!! */


// bbfx material paramters for world

#define	REG_cfAmbientIntensityW			register(c191)  /* reuse these registers for shaders that need 2 */
#define	REG_cfDiffuseIntensityW			register(c192)  /* reuse these registers for shaders that need 2 */
#define	REG_cfSpecularIntensityW		register(c193)  /* reuse these registers for shaders that need 2 */
#define	REG_cfSpecularPowerW			register(c194)  /* reuse these registers for shaders that need 2 */
#define	REG_cfReflectionIntensityW		register(c195)
#define	REG_cfSpecularBackscatterW		register(c196)  /* reuse these registers for shaders that need 2 */
#define	REG_cfLod_blend_beginW			register(c197) 
#define	REG_cfLod_blend_biasW			register(c198) 
#define	REG_cfIlluminationIntensityW	register(c199) 
#define	REG_cvSpecularColourW			register(c200)
#define	REG_cfReflectionLightingW		register(c201)
#define	REG_cfReflectionLtgPwrW			register(c202)
#define	REG_cfDiffuseIntensity1W		register(c192)
#define	REG_cfSpecularIntensity1W		register(c193)
#define	REG_cfSpecularPower1W			register(c194)
//#define	REG_cfReflectionIntensityW		register(c195)  /* note this is just here to let Andy know I need it in this group */
#define	REG_cfDiffuseIntensity2W		register(c196)
#define	REG_cfSpecularIntensity2W		register(c197)
#define	REG_cfSpecularPower2W			register(c198)
#define REG_cfDirtAmbientIntensityW		register(c191)
#define REG_cfDirtBackscatterW			register(c192)
#define REG_cfDirtSpecularIntensity		register(c193)
#define REG_cfDirtSpecularPowerW		register(c194)
#define REG_cfGrassAmbientIntensityW	register(c195)
#define REG_cfGrassBackscatterW			register(c196)
#define REG_cfGrassSpecularIntensityW	register(c197)
#define REG_cfGrassSpecularPowerW		register(c198)
#define REG_cfRockAmbientIntensityW		register(c199)
#define REG_cfRockSpecularIntensityW	register(c200)
#define REG_cfRockSpecularPowerW		register(c201)
#define	REG_cvDirtSpecularColorW		register(c202)
#define	REG_cvGrassSpecularColorW		register(c203)
#define	REG_cvRockSpecularColorW		register(c204)
#define	REG_cfDebugDiffuseTexW			register(c250)  
#define	REG_cfDebugSpecularTexW			register(c251) 
#define	REG_cfDebugNormalTexW			register(c252) 
#define	REG_cfDebugNormalScaleW			register(c253)
#define REG_cvFogValue					register(c206)
#define REG_cvFogColour					register(c207)
#define REG_cfSkyFogFalloff				register(c208)
#define REG_cfLightMapVertColBlend		register(c209)
#define REG_cvLightColour				register(c210)
#define REG_cvLightPosition				register(c211)
#define REG_cvFrustumVector				register(c212)
#define REG_cvSunHazeColour				register(c213)
#define REG_cfVSMEnabled				register(c214)
#ifndef SMOKE_XENON
#define REG_cvVertexPowerBrightness		register(c216)
#else
#define REG_cvVertexPowerBrightness		register(c62)
#endif
#define REG_cfDrawDepthOfField			register(c230)
#define REG_cfFogEnable					register(c240)
#define REG_CSMTransform				register(c249) /* 4 vectors [c249,c252] */

// Light Material Registers - alias REG_cavLightDirections

#define REG_cvDiffuseMin				register(c228)
#define REG_cvDiffuseRange				register(c229)
#define REG_cvEnvmapMin					register(c230)
#define REG_cvEnvmapRange				register(c231)
#define REG_cvSpecularMin				register(c232)
#define REG_cvSpecularRange				register(c233)
#define REG_cvSpecular1Min				register(c234)
#define REG_cvSpecular1Range			register(c235)
#define REG_cvPowers					register(c236)
#define REG_cvClampAndScales			register(c237)
#define REG_cvFlakes					register(c238)
#define REG_cvVinylScales				register(c239)

#define	REG_cvGradientParams            register(c240)
#define	REG_cvGradientColour            register(c241)
#define	REG_cvGradientColourE           register(c242)
#define	REG_ScreenRez                  	register(c243)
#define REG_cfScaleUVs					register(c244)
#define REG_cvVisualTreatmentParams		register(c245)
#define REG_cvVisualTreatmentParams2	register(c246)
#define REG_cvVisualTreatmentParams3	register(c247)
#define REG_cfCurrentTime				register(c248)


// for the constants heavy shader instancing
// 4 vectors, c4 to c7

#define REG_cvInstanceWorldSunColour		register(c61)
#define REG_cfSmokeLightInfluence			register(c60)
#define REG_cvInstanceWorldSunPosition		register(c59)
#define REG_cvInstanceData					register(c58)	// 4 Vectors
#define REG_cmInstanceVP					register(c54)
#define REG_cvInstanceWorldAmbientColour	register(c11)
#define REG_cvInstancedFogColour			register(c12)
#define REG_cvInstancedFogValue				register(c13)
#define REG_cvInstanceArray					register(c64)


// Aliased With Light Materials ...


</file>
  <file id="4" path="C:\D1017315-LeigpzigDemo\MW2\Branches\LeipzigDemo\Speed\Indep\Src\Render\effects\common\global_common.h" time="01c8f9c0-c76d0f4e">#ifndef __GLOBAL_COMMON_H__
#define __GLOBAL_COMMON_H__

//--------------------------------------------------------------------------------------
// Defines
//--------------------------------------------------------------------------------------
#define COMPILETIME_BOOL		uniform bool
#define PARABOLOIDBASIS_TRUE	true
#define PARABOLOIDBASIS_FALSE	false
#define INSTANCE_RENDER_TRUE	true
#define INSTANCE_RENDER_FALSE	false

//--------------------------------------------------------------------------------------
// Global Parameters
//--------------------------------------------------------------------------------------
float4x4	cmWorldViewProj		: REG_cmWorldViewProj;
float4x4	cmWorldView			: REG_cmWorldView;

float4	cvLocalLightVec			: REG_cvLocalLightVec;  // LOCALLIGHTDIRVECTOR;
float4	cvLocalEyePos			: REG_cvLocalEyePos;    // LOCALEYEPOS;

float4x4 cmWorldMat				: REG_cmWorldMat;				// WORLD
float4x4 cmWorldMatTranspose	: REG_cmWorldMatTranspose;

// Used to pass the world matrix transpose to the Shader when instance rendering.
float4x4	mWorldTransposeInstance;

// Used to pass the world matrix to the Shader when instance rendering.
float4x4	mWorldInstance;

// Used to pass the light and eye vectors to the PixelShader when instance rendering.
float3		vLocalLightDir;
float4		vLocalEyePos;

//--------------------------------------------------------------------------------------
// Functions - Used by instance rendering to deal with model space variables.
//--------------------------------------------------------------------------------------
float3 GetLocalLightDir(COMPILETIME_BOOL instanceRendering)
{
	if(!instanceRendering)
	{
		return cvLocalLightVec.xyz;
	}
	else
	{
		return vLocalLightDir;
	}
}

float3 GetLocalEyePos(COMPILETIME_BOOL instanceRendering)
{
	if(!instanceRendering)
	{
		return cvLocalEyePos.xyz;
	}
	else
	{
		return vLocalEyePos.xyz;
	}
}

//--------------------------------------------------------------------------------------
// Functions - Used by many shaders.
//--------------------------------------------------------------------------------------

inline float3 NormalTransform(float3 n, COMPILETIME_BOOL instanceRendering)
{
    /*
    Handle Mirror

    Object "mirroring" is a negative scale factor in the world matrix
    Mirror can be detected by crossing the RIGHT and OUT basis vectors
    If the UP vector points down (negative), we have a mirror transform.
    This is handled by applying the sign of the UP vector to the normal
    */

    float3 up;

    // Compile time branch
    if(instanceRendering)
    {
        up = cross(mWorldInstance[0].xyz,mWorldInstance[1].xyz );
    }
    else
    {
        up = cross(cmWorldMat[0].xyz,cmWorldMat[1].xyz );
    }
    n.xyz *= sign(up.z);

    return (n);
}

float bias(float b, float x)
{
return pow(x, log(b)/log(0.5));
}

//keep these around in case I need them
/*
float gain(float g, float x)
{
	float retVal	=  x &lt; 0.5 ? bias(1-g, 2*x)/2 : 1 - bias(1-g, 2 - 2*x)/2;
	return retVal;
}

float3 mix( float3 color0, float3 color1, float value )
{
return (1-value)*color0 + value*color1; 
}
*/

float valueOf(float3 colorVal)
{

	float minVal	= min(min(colorVal.r, colorVal.g), colorVal.b);
	float maxVal	= max(max(colorVal.r, colorVal.g), colorVal.b);
	float delta		= maxVal - minVal;

	float value		= maxVal;

	float satVal	= maxVal &gt; 0 ? delta/maxVal: 0;
	return value;
}

/*
float saturationOf(float3 colorVal)
{

	float minVal	= min(min(colorVal.r, colorVal.g), colorVal.b);
	float maxVal	= max(max(colorVal.r, colorVal.g), colorVal.b);
	float delta		= maxVal - minVal;

	float value		= maxVal;

	float satVal	= maxVal &gt; 0 ? delta/maxVal: 0;
	return satVal;
}

float hueOf(float3 colorVal)
{

	float minVal	= min(min(colorVal.r, colorVal.g), colorVal.b);
	float maxVal	= max(max(colorVal.r, colorVal.g), colorVal.b);
	float delta		= maxVal - minVal;

	float value		= maxVal;

	float satVal	= maxVal &gt; 0 ? delta/maxVal: 0;


	float hue		= colorVal.r == maxVal ? ((colorVal.g - colorVal.b)/delta ): 0;  // between yellow and magenta
	hue				= colorVal.g == maxVal ? (2 + (colorVal.b - colorVal.r)/delta) : hue; // between cyan and yellow
	hue				= colorVal.b == maxVal ? (4 + (colorVal.r - colorVal.g)/delta) : hue; // between magenta and cyan
	hue				*= 60;
	hue				= hue &lt; 0 ? hue + 360 : hue;

	return hue;
}
*/ 
#endif //__GLOBAL_COMMON_H__

</file>
  <file id="5" path="C:\D1017315-LeigpzigDemo\MW2\Branches\LeipzigDemo\Speed\Indep\Src\Render\effects\common\reflection.h" time="01c8f9c0-c76f71a8">// Copyright (C) Electronic Arts Canada Inc. 2008. All rights reserved.

#if !defined(_REFLECTION_H_)
#define _REFLECTION_H_

//#define ENVMAP_TESTING

float4x4 cmEnvMapParaboloid0Matrix;
float4x4 cmEnvMapParaboloid1Matrix;
float4x4 cmEnvMapParaboloid2Matrix;
float4x4 cmEnvMapCube0Matrix;
float4x4 cmEnvMapCube1Matrix;
float4x4 cmEnvMapCube2Matrix;
float4x4 cmEnvMapPlane0Matrix;

samplerCUBE ENVMAP_CUBE0_SAMPLER 
&lt;
string TextureSamplerState = "ENVMAP_SAMPLER";
&gt;;

samplerCUBE ENVMAP_CUBE1_SAMPLER 
&lt;
string TextureSamplerState = "ENVMAP_SAMPLER";
&gt;;

samplerCUBE ENVMAP_CUBE2_SAMPLER 
&lt;
string TextureSamplerState = "ENVMAP_SAMPLER";
&gt;;

sampler2D ENVMAP_PARABOLOID0_SAMPLER
&lt;
string TextureSamplerState = "ENVMAP_SAMPLER";
&gt;;

sampler2D ENVMAP_PARABOLOID1_SAMPLER
&lt;
string TextureSamplerState = "ENVMAP_SAMPLER";
&gt;;

sampler2D ENVMAP_PARABOLOID2_SAMPLER
&lt;
string TextureSamplerState = "ENVMAP_SAMPLER";
&gt;;

sampler2D ENVMAP_PLANE0_SAMPLER
&lt;
string TextureSamplerState = "ENVMAP_SAMPLER";
&gt;;

#define PARABOLOID_BASIS_FARPLANE 500.f
#define PARABOLOID_BASIS_NEARPLANE 0.1f

#define EnvironmentMapLookup_Car(xxworldspacereflectionvector, mipmaplevel)		EnvironmentMapLookup_Paraboloid_MipLevel(xxworldspacereflectionvector, ENVMAP_PARABOLOID1_SAMPLER, (float3x3)cmEnvMapParaboloid1Matrix, mipmaplevel)
//#define EnvironmentMapLookup_Car(xxworldspacereflectionvector)				EnvironmentMapLookup_Cube(xxworldspacereflectionvector, ENVMAP_CUBE0_SAMPLER, (float3x3)cmEnvMapCube0Matrix)
#define EnvironmentMapLookup_World(xxworldspacereflectionvector)				EnvironmentMapLookup_Paraboloid(xxworldspacereflectionvector, ENVMAP_PARABOLOID0_SAMPLER, (float3x3)cmEnvMapParaboloid0Matrix)
//#define EnvironmentMapLookup_World(xxworldspacereflectionvector)				EnvironmentMapLookup_Paraboloid_MipLevel(xxworldspacereflectionvector, ENVMAP_PARABOLOID0_SAMPLER, (float3x3)cmEnvMapParaboloid0Matrix, kEnvmipMipLevel)
//#define EnvironmentMapLookup_World(xxworldspacereflectionvector)				EnvironmentMapLookup_Cube(xxworldspacereflectionvector, ENVMAP_CUBE1_SAMPLER, (float3x3)cmEnvMapCube1Matrix)
#define EnvironmentMapLookup_Building(xxworldspacereflectionvector)				EnvironmentMapLookup_Paraboloid(xxworldspacereflectionvector, ENVMAP_PARABOLOID2_SAMPLER, (float3x3)cmEnvMapParaboloid2Matrix)
//#define EnvironmentMapLookup_Building(xxworldspacereflectionvector)			EnvironmentMapLookup_Cube(xxworldspacereflectionvector, ENVMAP_CUBE2_SAMPLER, (float3x3)cmEnvMapCube2Matrix)
#define EnvironmentMapLookup_Character(xxworldspacereflectionvector)			EnvironmentMapLookup_Paraboloid_MipLevel(xxworldspacereflectionvector, ENVMAP_PARABOLOID2_SAMPLER, (float3x3)cmEnvMapParaboloid2Matrix, CharBlurFactor)
//#define EnvironmentMapLookup_Character(xxworldspacereflectionvector)			EnvironmentMapLookup_Cube(xxworldspacereflectionvector, ENVMAP_CUBE2_SAMPLER, (float3x3)cmEnvMapCube2Matrix)
#define EnvironmentMapLookup_CarHeavenFloor(xxworldspacereflectionvector)		EnvironmentMapLookup_Plane(xxworldspacereflectionvector, ENVMAP_PLANE0_SAMPLER, cmEnvMapPlane0Matrix)

// Abstract the position basis for the reflection view so we can swap between
// paraboloid and standard cartesian basis without client code needing to know.
float4 EnvironmentMapLookup_Plane(float4 worldPosition, sampler2D envmapPlane, float4x4 world2envmap)
{
	float4 finalReflect = mul(worldPosition + float4(0, 0, 0.0, 0), world2envmap);
	//finalReflect.xyz *= float3(1, 1, 1);
	finalReflect.y = 1 - (finalReflect.y + 1.09);
	float4 texcoords = float4(((finalReflect.xyz/finalReflect.www) + 1.0f) * 0.5f, 1);
	return tex2Dproj(envmapPlane, texcoords);
}

float4 EnvironmentMapLookup_Cube(float3 reflectionVector, samplerCUBE envmapCube, float3x3 world2envmap)
{
	reflectionVector.y = -reflectionVector.y;
	float4 envMapSample = texCUBE(envmapCube, mul(reflectionVector, world2envmap).xyz);

	return envMapSample;
}

float4 EnvironmentMapLookup_Paraboloid(float3 reflectionVector, samplerCUBE envmapCube, float3x3 world2envmap)
{
	float3 pbmsReflection = mul(reflectionVector, world2envmap);
	
	float scale = 1.4;
	float3 refFront;
	refFront.x = (pbmsReflection.x / (1*(1 + pbmsReflection.z))) + 0.0;
	refFront.y = (-pbmsReflection.y / (1*(1 + pbmsReflection.z))) + 0.0;
	refFront.z = 1 / scale;

	float3 refBack;
	refBack.x = (pbmsReflection.x / (1*(1 - pbmsReflection.z))) + 0.0;
	refBack.y = ((pbmsReflection.y / (1*(1 - pbmsReflection.z))) + 0.0);
	refBack.z = -1 / scale;

	float4	envmap_sampleF = texCUBE(envmapCube, refFront.xyz);
	float4	envmap_sampleB = texCUBE(envmapCube, refBack.xyz);

	float4	envmap_sample = 0; //float4(1, 1, 1, 1);
	
	// Branch is acceptable as this is effectively debugging code
	if (pbmsReflection.z &gt; 0)
	{
		envmap_sample = envmap_sampleF;
	}
	else
	{
		envmap_sample = envmap_sampleB;
	}
	return envmap_sample;
}

float4 EnvironmentMapLookup_ParaboloidUVUV(float3 pbmsReflection)
{
	float2 refFront;
	refFront.x = (pbmsReflection.x / (1*(1 + pbmsReflection.z))) + 0.0;
	refFront.y = (pbmsReflection.y / (1*(1 + pbmsReflection.z))) + 0.0;

	float2 refBack;
	refBack.x = (pbmsReflection.x / (1*(1 - pbmsReflection.z))) + 0.0;
	refBack.y = ((pbmsReflection.y / (1*(1 - pbmsReflection.z))) + 0.0);

	float2	envmap_sampleF = float2(0.5, 0.25) * refFront.xy + float2(0.5, 0.25);
	float2	envmap_sampleB = float2(0.5, 0.25) * refBack.xy + float2(0.5, 0.75);

	envmap_sampleB.x = 1 - envmap_sampleB.x;
	return float4(envmap_sampleF, envmap_sampleB);
}

float4 EnvironmentMapLookup_Paraboloid(float3 reflectionVector, sampler2D envmapParaboloid, float3x3 world2envmap)
{
	float3 pbmsReflection = mul(reflectionVector, world2envmap);

	float4 uvuv = EnvironmentMapLookup_ParaboloidUVUV(reflectionVector);
	float4	envmap_sampleF = tex2D(envmapParaboloid, uvuv.xy);
	float4	envmap_sampleB = tex2D(envmapParaboloid, uvuv.zw);

	float4	envmap_sample = 0;
	if (pbmsReflection.z &gt; 0)
	{
		envmap_sample = envmap_sampleF;
	}
	else
	{
		envmap_sample = envmap_sampleB;
	}
	return envmap_sample;
}

float4 EnvironmentMapLookup_Paraboloid_MipLevel(float3 reflectionVector, sampler2D envmapParaboloid, float3x3 world2envmap, float miplevel)
{
	float3 pbmsReflection = mul(reflectionVector, world2envmap);

	float4 uvuv = EnvironmentMapLookup_ParaboloidUVUV(reflectionVector);

#if defined(SHADERMODEL_3_0)
	float4	envmap_sampleF = tex2Dlod(envmapParaboloid, float4(uvuv.xy, 0.f, miplevel));
	float4	envmap_sampleB = tex2Dlod(envmapParaboloid, float4(uvuv.zw, 0.f, miplevel));
#elif defined(SHADERMODEL_2_0)
	float4	envmap_sampleF = tex2D(envmapParaboloid, uvuv.xy);
	float4	envmap_sampleB = tex2D(envmapParaboloid, uvuv.zw);
#else
#error Unsupported shadermodel
#endif

	float4	envmap_sample = 0;
	if (pbmsReflection.z &gt; 0)
	{
		envmap_sample = envmap_sampleF;
	}
	else
	{
		envmap_sample = envmap_sampleB;
	}
	return envmap_sample;
}

float4 world_paraboloid_position( float4 modelspace_position )
{
 	float4 p = mul(modelspace_position, cmWorldView);
#if defined(ENABLE_SCREENOFFSET)
	p.xy += cvScreenOffset.xy * p.w;
#endif // ENABLE_SCREENOFFSET
	p /= p.w;
	float L = length(p.xyz);
	p /= L;
	p.z += 1;
	p.x = p.x / p.z;
	p.y = -p.y / p.z;
	p.z = (L - PARABOLOID_BASIS_NEARPLANE) / (PARABOLOID_BASIS_FARPLANE - PARABOLOID_BASIS_NEARPLANE);
	p.w = 1;
    return p;
}

#endif	// _REFLECTION_H_
</file>
  <file id="6" path="C:\D1017315-LeigpzigDemo\MW2\Branches\LeipzigDemo\Speed\Indep\Src\Render\effects\common\gamma.h" time="01c8f9c0-c76d0f4e">#ifndef _GAMMA_H
#define _GAMMA_H

//////////////////////////////////////////////////////
// DEFINES
//////////////////////////////////////////////////////

//////////////////////////////////////////////////////
// GLOBAL FUNCTIONS
//////////////////////////////////////////////////////

// Linear to Gamma 2.0 transform (c^0.5)
inline float3 GammaCompress( float3 c ) 
{ 
    return sqrt(c);  
}

// Gamma 2.0 to linear transform (c*c)
inline float3 GammaExpand( float3 c )   
{ 
    return c * c;
}

#endif //_GAMMA_H
</file>
  <file id="7" path="C:\D1017315-LeigpzigDemo\MW2\Branches\LeipzigDemo\Speed\Indep\Src\Render\effects\common\mw2_lighting_models.h" time="01c8f9c0-c76d0f4e">#ifndef MW2_LIGHTING_MODELS_H
#define MW2_LIGHTING_MODELS_H

//--------------------------------------------------------------------------------------
// Define All Lighting Models Here, this includes lighting models like 
// Blinn, Lambert, cook-torrence, BRDF look-up table etc
//--------------------------------------------------------------------------------------

float3 BlinnSpecRoad( float3 view_dir, float3 light_dir, float3 normal, float4 specularPower, float4 specularColour )
{

	float3 OUT;

	float3 half_angle = normalize(view_dir + light_dir);

	float cosnh = saturate(dot(half_angle, normal));

	float denom = 1.0 + -0.96 * pow(cosnh,specularPower.y);
	float dd;
	dd = (0.05) / denom;

	OUT = cosnh * dd * dd * specularColour.xyz * specularColour.w;
//	OUT = float3(1,0,0);
	
	return OUT;
}

//===========================================================================

float3 BlinnSpec( float3 view_dir, float3 light_dir, float3 normal, float n )
{

	float3 OUT;

	float3 half_angle = normalize(view_dir + light_dir);
	OUT = pow(saturate(dot( half_angle, normal )), n );
		
	return OUT;

}

//===========================================================================

float3 LightingModel( float diffuse, float shadow, float3 base, float ambient_occlusion, float vertex_colour, float3 worldAmbientColour, float3 worldSunColour )
{
	float3 final;

	//  worldAmbientColour         ... Ambient Color
	//  worldSunColour             ... Sun Color 
	//  lighting_val_diffuse         ... NdotL * Shadow
	//  vertex_colour         ... Vertex Ambient Occlusion
	//  ambient_occlusion            ... Texture Ambient Occlusion
	//  base.xyz                     ... Diffuse

	// Create Light Wrap Around To Soften The World Lighting (Helps a lot!!!!)
//	if ( diffuse &lt; -0.2 ) // Might still be needed to handle shadow cutoffs
//		shadow = 1;
	diffuse = (0.2 + diffuse) / 1.2; // This creates wrap around lighting... prevent cg look to game

	// Use reverse side of diffuse to take away flat look of game....
	float diffuse_rev = 0.7 + 0.3* saturate(diffuse+1);

	// Prevent negative lighting effects...
	diffuse = max(0.0, diffuse);

	// Add up lighting in game....
	float3 lighting_val_diffuse = diffuse * shadow;
	float3 lighting_lighten = worldSunColour * lighting_val_diffuse;
	//float3 lighting_lighten = float3(0.9, 0.5, 0.2) * lighting_val_diffuse;

	// Base Texture...
	final.xyz = base.xyz * ambient_occlusion;

	// Ambient with falloff...
	float3 ambient_new = worldAmbientColour * diffuse_rev;
	//float3 ambient_new = float3(0.0, 0.0, 0.5) * diffuse_rev;

	//apply lighting
	//final.xyz *= (lighting_lighten + ambient_new) * pow(ambient_occlusion,2.2) + (1.5 * ambient_new); // Simplified CH
	final.xyz *= (lighting_lighten + ambient_new) + (1.5 * ambient_new); // Simplified CH

	//apply vertex occ
//	final.xyz *= lerp(vertex_colour,1,lighting_val_diffuse); // Not sure there is a hardware lerp inst... so below should be faster????
	final.xyz *= (1-lighting_val_diffuse) + lighting_val_diffuse;

	return final;

}

//===========================================================================

float3 BasicLightingModel( float diffuse, float shadow, float3 base, float3 worldAmbientColour, float3 worldSunColour )
{
	float3 final;

	//  worldAmbientColour         ... Ambient Color
	//  worldSunColour             ... Sun Color 
	//  lighting_val_diffuse         ... NdotL * Shadow
	//  base.xyz                     ... Diffuse

	// Use reverse side of diffuse to take away flat look of game....
	float diffuse_rev = 1 - diffuse;

	// Add up lighting in game....
	float3 lighting_val_diffuse = diffuse * shadow;
	float3 lighting_lighten = worldSunColour * lighting_val_diffuse;

	// Base Texture...
	final.xyz = base.xyz;

	// Ambient with falloff...
	float3 ambient_new = worldAmbientColour * diffuse_rev;

	//apply lighting
	final.xyz *= lighting_lighten + ambient_new;

	return final;

}

//===========================================================================

float3 BasicAOLightingModel( float diffuse, float shadow, float3 base, float ambient_occlusion, float3 worldAmbientColour, float3 worldSunColour )
{
	float3 final;

	//  worldAmbientColour         ... Ambient Color
	//  worldSunColour             ... Sun Color 
	//  lighting_val_diffuse         ... NdotL * Shadow
	//  base.xyz                     ... Diffuse

	float darken = shadow;

	// Add up lighting in game....
	float lighting_val_diffuse = diffuse * darken ;

	// Use reverse side of diffuse to take away flat look of game....
	float diffuse_rev = 1 - lighting_val_diffuse;


	float3 lighting_lighten = worldSunColour * lighting_val_diffuse;

	// Base Texture...
	final.xyz = base.xyz;

	// Ambient with falloff...
	float3 ambient_new = worldAmbientColour * diffuse_rev;

	//apply lighting
	final.xyz *= lighting_lighten + ambient_new;
	final.xyz *= ambient_occlusion;// per DTaylor we put ao into the shadows

	//debug
	//final.xyz = ambient_new;
	//final.xyz = worldAmbientColour;
	//final.xyz = lighting_lighten;
	//final.xyz = lighting_val_diffuse;

	return final;

}

//===========================================================================

float3 BasicAOLightingModelRoad( float diffuse, float shadow, float3 base, float ambient_occlusion, float3 worldAmbientColour, float3 worldSunColour, float diffuse_wrap )
{
	float3 final;

	//  worldAmbientColour         ... Ambient Color
	//  worldSunColour             ... Sun Color 
	//  lighting_val_diffuse         ... NdotL * Shadow
	//  base.xyz                     ... Diffuse

	//diffuse = (diffuse_wrap + diffuse) / (1 + diffuse_wrap); // This creates wrap around lighting... prevent cg look to game
	diffuse = saturate(bias(diffuse_wrap,(diffuse+1 )/2)*2-1);

	//float darken = ambient_occlusion * shadow;
	float darken = shadow;

	// Add up lighting in game....
	float lighting_val_diffuse = diffuse * darken ;

	// Use reverse side of diffuse to take away flat look of game....
	float diffuse_rev = 1 - lighting_val_diffuse;


	float3 lighting_lighten = worldSunColour * lighting_val_diffuse;

	// Base Texture...
	final.xyz = base.xyz;

	// Ambient with falloff...
	float3 ambient_new = worldAmbientColour * diffuse_rev;

	//apply lighting
	final.xyz *= lighting_lighten + ambient_new;
	final.xyz *= ambient_occlusion;// per DTaylor we put ao into the shadows

	//debug
	//final.xyz = ambient_new;
	//final.xyz = worldAmbientColour;
	//final.xyz = lighting_lighten;
	//final.xyz = lighting_val_diffuse;
	//final.xyz = saturate(-(diffuse+ diffuse_wrap));
	//final.xyz = saturate(bias(diffuse_wrap,(diffuse+1 )/2)*2-1);

	return final;

}

//===========================================================================

float3 BasicAOLightingModelVertex( float diffuse, float ambient_occlusion, float3 worldAmbientColour, float3 worldSunColour )
{
	float3 final = 1;

	float darken = ambient_occlusion;

	// Add up lighting in game....
	float lighting_val_diffuse = diffuse * darken ;

	// Use reverse side of diffuse to take away flat look of game....
	float diffuse_rev = 1 - lighting_val_diffuse;

	float3 lighting_lighten = worldSunColour * lighting_val_diffuse;

	// Ambient with falloff...
	float3 ambient_new = worldAmbientColour * diffuse_rev;

	//apply lighting
	final.xyz *= lighting_lighten + ambient_new;

	//debug
	//final.xyz = ambient_new;
	//final.xyz = worldAmbientColour;
	//final.xyz = lighting_lighten;
	//final.xyz = diffuse;

	return final;

}

#endif
</file>
  <file id="8" path="C:\D1017315-LeigpzigDemo\MW2\Branches\LeipzigDemo\Speed\Xenon\Src\Render\effects\shadowmap_fx_def.h" time="01c8f9c5-4d521c5e">
#ifndef _SHADOWMAP_FX_DEF_H
#define _SHADOWMAP_FX_DEF_H

/////////////////////////////////////////////////////////////////////////////////////////
#include "shadowenum.h"
#include "depth.h"

shared float4x4	cmShadowMapWVP			: REG_cmShadowMapWVP;
shared float4x4	cmShadowMapVP			: REG_cmShadowMapVP;
shared float4x4 cmLightWVP				: REG_cmLightWVP;
shared float4x4 cmShadowMapBiasMatrix	: REG_cmShadowMapBiasMatrix;

shared float4 cvAmbientColour			: REG_cvAmbientColour;
shared float4 cvShadowParams0			: REG_cvShadowParams0;
shared float4 cvShadowParams1			: REG_cvShadowParams1;

shared float cfVSMEnabled				: REG_cfVSMEnabled;


#define	cfShadowMapAlphaMin cvShadowParams0.x
#define	cfShadowMapBiasA	cvShadowParams0.y
#define	cfShadowMapBiasB	cvShadowParams0.z
#define	cfVSMEpsilon		cvShadowParams0.w

#define	ShadowMapNdotLBiasOffset	cvShadowParams1.x
#define	ShadowMapNdotLBiasScale		cvShadowParams1.y
#define	ShadowMapVSMThreshold		cvShadowParams1.z
#define	ShadowMapWingMirrorBias		cvShadowParams1.w

#define SHADOWMAP_C1				0.2f
#define SHADOWMAP_C2				0.1f

#define BIAS 0.00005f

//#define cfShadowMapScaleY	cvShadowParams1.w


//#define ENABLE_SHADOW_STENCIL_MASK
//#define SHADOW_LOD_ON

#define FADE_SHADOW

/////////////////////////////////////////////////////////////////////////////////////////

sampler2D SHADOWMAP_SAMPLER
&lt;
	string TextureSamplerState = "SHADOWMAP_SAMPLER";
&gt;;

/////////////////////////////////////////////////////////////////////////////////////////

float CalculateShadowFade(float4 shadowTex)
{
	float2 edgeAttenuation = shadowTex.xy / shadowTex.w;
	edgeAttenuation = saturate(1 - pow(edgeAttenuation,4));
	return (1 - edgeAttenuation.x * edgeAttenuation.y);
}

/////////////////////////////////////////////////////////////////////////////////////////

float4 VertexShadowTex( float4 v_position, COMPILETIME_BOOL instanceRender )
{
	v_position.w = 1.0f;
	if(instanceRender)
	{
		return mul( v_position, mWorldInstance );
	}
	else
	{
		return mul( v_position, cmWorldMat );
	}
}

float4 VertexShadowTexOptimized( const float4 v_position, float ndotl, out float shadow_fade, COMPILETIME_BOOL instanceRender)
{
	shadow_fade =  1.0f;
	return VertexShadowTex( v_position, instanceRender );
}

/////////////////////////////////////////////////////////////////////////////////////////

float4 Tex2DOffset( sampler2D ss, float2 uv, float2 offset )
{
	float4 result;
	float offsetx = offset.x;
	float offsety = offset.y;

	asm
	{
		tfetch2D result, uv, ss, OffsetX=offsetx, OffsetY=offsety
	};

	return result;
}

float4x4 cmCSM0ShadowMapWVP;
float4x4 cmCSM1ShadowMapWVP;
float4x4 cmCSM2ShadowMapWVP;

const float kShadowMapWidth = 1024.0f;
const float kShadowMapHeight = 1024.0f;

inline float GetEdgeContrast(float2 shadowUV)
{
    #define EDGE_RADIUS 2.0

    float4 tap;
    float2 ret;

    asm
    {
        tfetch2D tap.x___, shadowUV, SHADOWMAP_SAMPLER, OffsetX =-EDGE_RADIUS, OffsetY = EDGE_RADIUS
        tfetch2D tap._x__, shadowUV, SHADOWMAP_SAMPLER, OffsetX = EDGE_RADIUS, OffsetY = EDGE_RADIUS
        tfetch2D tap.__x_, shadowUV, SHADOWMAP_SAMPLER, OffsetX =-EDGE_RADIUS, OffsetY =-EDGE_RADIUS
        tfetch2D tap.___x, shadowUV, SHADOWMAP_SAMPLER, OffsetX = EDGE_RADIUS, OffsetY =-EDGE_RADIUS
    };

    // edge detect
    float edge;

    edge=0;
    edge += abs(tap.x-tap.y);
    edge += abs(tap.z-tap.w);
    edge += abs(tap.x-tap.w);
    edge += abs(tap.y-tap.z);

    return (edge);
}

inline float SamplePCF(float2 shadowUV, float lightDepth)
{
    float4 pcfSamples0;
    float4 pcfSamples1;
    float  ret;

    asm
    {
        tfetch2D pcfSamples0.x___, shadowUV, SHADOWMAP_SAMPLER, OffsetX = -0.5, OffsetY = -0.5
        tfetch2D pcfSamples0._x__, shadowUV, SHADOWMAP_SAMPLER, OffsetX =  0.5, OffsetY = -0.5
        tfetch2D pcfSamples0.__x_, shadowUV, SHADOWMAP_SAMPLER, OffsetX = -0.5, OffsetY =  0.5
        tfetch2D pcfSamples0.___x, shadowUV, SHADOWMAP_SAMPLER, OffsetX =  0.5, OffsetY =  0.5
        tfetch2D pcfSamples1.x___, shadowUV, SHADOWMAP_SAMPLER, OffsetX = -1.5, OffsetY = -1.0
        tfetch2D pcfSamples1._x__, shadowUV, SHADOWMAP_SAMPLER, OffsetX =  1.5, OffsetY = -1.0
        tfetch2D pcfSamples1.__x_, shadowUV, SHADOWMAP_SAMPLER, OffsetX = -1.5, OffsetY =  1.0
        tfetch2D pcfSamples1.___x, shadowUV, SHADOWMAP_SAMPLER, OffsetX =  1.5, OffsetY =  1.0
    };

    pcfSamples0.xyzw = lightDepth &gt; pcfSamples0.xyzw;
    pcfSamples1.xyzw = lightDepth &gt; pcfSamples1.xyzw;
    ret  = dot(pcfSamples0, .125); // .125 to normalize the 8 samples
    ret += dot(pcfSamples1, .125); 

    return (ret);
}

float DoCSM3ShadowPCF( const float4 shadow_pos )
{
    const float EDGE = 0.99;

    float4 shadowTex0 = mul( shadow_pos, cmCSM0ShadowMapWVP );
    float4 shadowTex1 = mul( shadow_pos, cmCSM1ShadowMapWVP );
    float4 shadowTex2 = mul( shadow_pos, cmCSM2ShadowMapWVP );

    float4 shadowTex;
    float2 shadowUV;

    if ( abs(shadowTex2.x) &gt; EDGE || abs(shadowTex2.y) &gt; EDGE )
    {
        return 1.0f;
    }
    else if ( abs(shadowTex0.x) &lt; EDGE &amp;&amp; abs(shadowTex0.y) &lt; EDGE )
    {
        shadowTex = shadowTex0;
        shadowUV = float2(shadowTex.x/6.0f + (1.0f/6.0f),-shadowTex.y*0.5 + 0.5);
    }
    else if ( abs(shadowTex1.x) &lt; EDGE &amp;&amp; abs(shadowTex1.y) &lt; EDGE )
    {
        shadowTex = shadowTex1;
        shadowUV = float2(shadowTex.x/6.0f + (3.0f/6.0f),-shadowTex.y*0.5 + 0.5);
    }
    else //will pass when ( abs(shadowTex2.x) &lt; EDGE &amp;&amp; abs(shadowTex2.y) &lt; EDGE )
    {
        shadowTex = shadowTex2;
        shadowUV = float2(shadowTex.x/6.0f + (5.0f/6.0f),-shadowTex.y*0.5 + 0.5);
    }

    float lightDepth = shadowTex.z;
    float ret;
    float4 ctr;

    asm
    {
        // tap center
        tfetch2D ctr.x___, shadowUV, SHADOWMAP_SAMPLER
    };

#if defined (DEPTH_HIZ)
    // this places the light depth into inverted depth space
    // doing this avoids inverting all the depth taps
    lightDepth = 1-lightDepth;
#endif

    // add bias to remove acne
    lightDepth = lightDepth + BIAS;

    // solve center depth test
    float centerResult = lightDepth &gt; ctr.x;

    // edge detect
    if (GetEdgeContrast(shadowUV) &lt; .5)
    {
        // not on an edge, filtering not needed: early out 
        // return center result
        return centerResult;
    }

    // pcf sample
    ret = SamplePCF(shadowUV,lightDepth);

    // accumulate center sample
    ret += centerResult;

    // ret = (pcf + center) / 2
    return (ret/2);
}

#if 0
//Save for reference
float DoCSM3Shadow const float4 shadow_pos )
{
    /* texcorrd math removed ... the interesting stuff is the bilinear weighting below */
	float4 pcfSamples;

	asm
	{
		tfetch2D pcfSamples.x___, shadowUV, SHADOWMAP_SAMPLER, OffsetX = -0.5, OffsetY = -0.5
		tfetch2D pcfSamples._x__, shadowUV, SHADOWMAP_SAMPLER, OffsetX =  0.5, OffsetY = -0.5
		tfetch2D pcfSamples.__x_, shadowUV, SHADOWMAP_SAMPLER, OffsetX = -0.5, OffsetY =  0.5
		tfetch2D pcfSamples.___x, shadowUV, SHADOWMAP_SAMPLER, OffsetX =  0.5, OffsetY =  0.5
	};

	pcfSamples = step( pcfSamples, lightDepth - 0.0000f );

	shadowTex.xy = ( shadowTex.xy + 1.0f ) * 512.0f + 0.5f;

	float2 modfUnused;
	shadowTex.xy = modf( shadowTex.xy, modfUnused );

	float shadowBot = lerp( pcfSamples.x, pcfSamples.y, shadowTex.x );
	float shadowTop = lerp( pcfSamples.z, pcfSamples.w, shadowTex.x );

	float shadow = lerp( shadowTop, shadowBot, shadowTex.y );

	shadow = 1.0 - shadow;

	return 0.2f + ( 0.8f * shadow );
}
#endif //SAVE FOR REFERENCE

float DoShadow( const float4 shadow_pos, const float ndotl, int shadowDetail = ShadowShaderDetail_HIGH )
{
	float shadowmap = 0;
    
    shadowmap=DoCSM3ShadowPCF(shadow_pos);
    //shadowmap=DoCSM3Shadow_ORIG(shadow_pos);
	float adjusted_ndotl = max(SHADOWMAP_C2, saturate(ndotl));
	return lerp(0.0f, shadowmap, saturate(adjusted_ndotl - SHADOWMAP_C2)/(SHADOWMAP_C1 - SHADOWMAP_C2));
}

float DoShadowPCF( const float4 shadow_pos, const float ndotl, float shadow_fade, int shadowDetail = ShadowShaderDetail_HIGH)
{
	float shadowmap = 0;
    
    shadowmap=DoCSM3ShadowPCF(shadow_pos);
    //shadowmap=DoCSM3Shadow_ORIG(shadow_pos);
	float adjusted_ndotl = max(SHADOWMAP_C2, saturate(ndotl));
	return lerp(0.0f, shadowmap, saturate(adjusted_ndotl - SHADOWMAP_C2)/(SHADOWMAP_C1 - SHADOWMAP_C2));
}

float DoShadowOptimized( const float4 shadowTex, const float ndotl, float shadow_fade, int shadowDetail = ShadowShaderDetail_HIGH)
{
	return DoShadowPCF( shadowTex, ndotl, shadowDetail);
}

/////////////////////////////////////////////////////////////////////////////////////////


float DoShadowCar( const float4 shadowTex, const float ndotl, int shadowDetail = ShadowShaderDetail_HIGH )
{
	return DoShadow(shadowTex, ndotl, shadowDetail);
}

// handle legacy call (deprecated)
#define DoCSM3Shadow DoCSM3ShadowPCF

#endif
</file>
  <file id="9" path="C:\D1017315-LeigpzigDemo\MW2\Branches\LeipzigDemo\Speed\Indep\Src\Render\effects\common\shadowenum.h" time="01c8f9c0-c76f71a8">#ifndef SHADOWENUM_H
#define SHADOWENUM_H

// these numbers should match up with the enumerations in ShadowShaderDetail in eEffect.hpp
// (should make these in a header thats included by both fxc and the game compiler)
static const int ShadowShaderDetail_OFF = 0;
static const int ShadowShaderDetail_LOW = 1;
static const int ShadowShaderDetail_MEDIUM = 2;
static const int ShadowShaderDetail_HIGH = 3;

#endif
</file>
  <file id="10" path="C:\D1017315-LeigpzigDemo\MW2\Branches\LeipzigDemo\Speed\Xenon\Src\Render\effects\depth.h" time="01c8f9c5-4d521c5e">#ifndef DEPTH_H
#define DEPTH_H

// XBOX 360

#define DEPTH_HIZ

//--------------------------------------------------------------------------------------
// GLOBAL FUNCTIONS
//--------------------------------------------------------------------------------------

// at (uv), returns homogeneous depth, where 0 is the near plane, and 1 is the far plane
float DepthSampleDepth(sampler2D s, float2 uv)
{
    float depth = tex2D( s, uv.xy ).x;

#if defined (DEPTH_HIZ)
    // inverted depth transform
    depth = 1-depth;
#endif

    return (depth);
}

#endif // DEPTH_H
</file>
  <file id="11" path="C:\D1017315-LeigpzigDemo\MW2\Branches\LeipzigDemo\Speed\Indep\Src\Render\effects\common\hdr.h" time="01c8f9c0-c76d0f4e">#ifndef HDR_H
#define HDR_H

float3 HdrExpand(float4 alphaOverbright)
{
    // alpha 0 will produce no change to the color
    // alpha 1 will double the color

    // this fits perfectly with our dynamic range of 0-2
    // with full alpha it is possible to hit the max possible color
    return (alphaOverbright.rgb * (1+alphaOverbright.a));
}

#endif //HDR_H
</file>
  <file id="12" path="C:\D1017315-LeigpzigDemo\MW2\Branches\LeipzigDemo\Speed\Indep\Src\Render\effects\common\mw2_shadow_csm.h" time="01c8f9c0-c76d0f4e">
#ifndef _MW2_SHADOW_CSM_H
#define _MW2_SHADOW_CSM_H

/********************************************************************
	file:		mw2_shadow_csm.h
	purpose:	techniques for CSM shadows
*********************************************************************/

#ifdef ALPHA
#ifndef SHADOW_SAMPLER
#define SHADOW_SAMPLER OPACITY_SAMPLER
#endif
#endif

#ifndef SHADOW_SAMPLER_CHANNEL
#define SHADOW_SAMPLER_CHANNEL b
#endif

float4x4 cmCSMTransform : REG_cmCSMTransform;

struct CSM_PS_INPUT
{
	float4 position		: POSITION;
#ifdef PLAT_PC
	float  depth		: TEXCOORD0;
#endif
#ifdef ALPHA
	float2 diffuseTex	: TEXCOORD1;
#endif
};

#ifdef ALPHA
CSM_PS_INPUT VSCSM( float4 position : POSITION, const float2 texUV : TEXCOORD0 )
#else
CSM_PS_INPUT VSCSM( float4 position : POSITION )
#endif
{
	CSM_PS_INPUT OUT;

#if defined(CAR_SHADER) &amp;&amp; defined(PLAT_PC)
	position = position * 10.f;
#endif
	position.w = 1.0f;
	position = mul( cmWorldMatTranspose, position );
	position = mul( position, cmCSMTransform );

	OUT.position = position;
#ifdef PLAT_PC
	OUT.position.y = -OUT.position.y;
	OUT.depth = position.z; 
#endif
#ifdef ALPHA
#ifdef CAR_SHADER
	OUT.diffuseTex.xy = texUV.xy;
#else
	OUT.diffuseTex.xy = DeCompressTextCoords(texUV.xy);
#endif
#endif

	return OUT;
}

#if defined( PLAT_PC ) || defined( ALPHA )
float4 PSCSM( const CSM_PS_INPUT input ) : COLOR0
{
#ifdef ALPHA
	float4 v_tex = tex2D( SHADOW_SAMPLER, input.diffuseTex );
	clip( v_tex.SHADOW_SAMPLER_CHANNEL - 0.2 );
#endif
#ifdef PC
	return float4( input.depth, input.depth, input.depth, input.depth );
#else
	return 0.0f;
#endif
}
#endif

/////////////////////////////////////////////////////////////////////////////////////////

technique RenderCSM
&lt;
	string viewtag = "SHADOW";
	string lostag = "ANY";
&gt;
{
	pass p0
	&lt;
		string depthstencil = "default";
		string blend = "default";
		string rasterizer = "default";
	&gt;
	{
		VertexShader = compile vs_2_0 VSCSM();
#if defined( PLAT_PC ) || defined( ALPHA )
		PixelShader = compile ps_2_0 PSCSM();
#else
		PixelShader = NULL;
#endif
	}
}

#endif
</file>
 </files>
 <tool name="Compiler">
  <defines>
   <define name="SHADER_DEBUG" value="" />
   <define name="PLAT_XENON" value="" />
   <define name="SHADERMODEL_3_0" value="" />
  </defines>
  <arguments>
   <argument name="/Zi" value="false" />
   <argument name="/Vd" value="false" />
   <argument name="/Xu0_deprecated" value="false" />
   <argument name="/Odu_deprecated" value="false" />
   <argument name="/XOd_" value="false" />
   <argument name="/XOu" value="false" />
   <argument name="/Xmaxtempreg" value="0" />
   <argument name="PsSampBase" value="0" />
   <argument name="PsSampCount" value="0" />
   <argument name="VsSampBase" value="0" />
   <argument name="VsSampCount" value="0" />
   <argument name="VsInstCount" value="0" />
   <argument name="PsInstCount" value="0" />
   <argument name="/Od" value="false" />
   <argument name="/Zpr" value="true" />
   <argument name="/Zpc" value="false" />
   <argument name="/Gpp" value="false" />
   <argument name="/Op" value="false" />
   <argument name="/Gfa" value="false" />
   <argument name="/Gfp" value="true" />
   <argument name="/XZc:zeroInit" value="false" />
   <argument name="/XVe" value="false" />
   <argument name="/Xbe:3-" value="false" />
   <argument name="/Xbe:1-" value="false" />
   <argument name="/XQInomaskedexports" value="false" />
   <argument name="/XOautoz" value="false" />
  </arguments>
 </tool>
 <shaders>
  <shader entrypoint="VM_NoPara" target="vs_3_0" ZPass="0" pdbHint="4e4a0000-27587e36-fa652e26">
   <constanttable>
    <constant register="c34">
     <type name="ambient_occlusion_bias" class="scalar" type="float" />
    </constant>
    <constant register="c4" count="4">
     <type name="cmWorldMat" class="matrix_rows" type="float" rows="4" columns="4" />
    </constant>
    <constant register="c24" count="4">
     <type name="cmWorldViewProj" class="matrix_rows" type="float" rows="4" columns="4" />
    </constant>
   </constanttable>
   <sourcemap>
    <statement pc="3" file="1" line="182" scope="-1" lastinstruction="0" />
    <statement pc="4" file="1" line="182" scope="-1" lastinstruction="0" />
    <statement pc="5" file="1" line="182" scope="-1" lastinstruction="0" />
    <statement pc="6" file="1" line="182" scope="-1" lastinstruction="0" />
    <statement pc="7" file="1" line="182" scope="-1" lastinstruction="0" />
    <statement pc="0.1" file="1" line="182" scope="-1" lastinstruction="0" />
    <statement pc="8" file="2" line="30" scope="-1" lastinstruction="0" />
    <statement pc="9" file="2" line="30" scope="-1" lastinstruction="0" />
    <statement pc="10" file="2" line="30" scope="-1" lastinstruction="0" />
    <statement pc="11" file="2" line="30" scope="-1" lastinstruction="0" />
    <statement pc="1.1" file="2" line="30" scope="-1" lastinstruction="0" />
    <statement pc="12" file="4" line="95" scope="-1" lastinstruction="0" />
    <statement pc="13" file="4" line="95" scope="-1" lastinstruction="0" />
    <statement pc="14" file="8" line="71" scope="-1" lastinstruction="0" />
    <statement pc="15" file="8" line="71" scope="-1" lastinstruction="0" />
    <statement pc="16" file="4" line="95" scope="-1" lastinstruction="0" />
    <statement pc="17" file="4" line="95" scope="-1" lastinstruction="0" />
    <statement pc="18" file="1" line="141" scope="-1" lastinstruction="0" />
    <statement pc="19" file="8" line="71" scope="-1" lastinstruction="0" />
    <statement pc="20" file="1" line="184" scope="-1" lastinstruction="0" />
    <statement pc="21" file="1" line="184" scope="-1" lastinstruction="0" />
    <statement pc="22" file="1" line="184" scope="-1" lastinstruction="0" />
    <statement pc="23" file="1" line="184" scope="-1" lastinstruction="0" />
   </sourcemap>
   <variables>
   </variables>
   <variableDebugInfo>
   </variableDebugInfo>
   <scopes>
   </scopes>
   <funcInfo>
    <function id="0" name="VSCSM" retID="392">
     <parameter id="391" />
    </function>
    <function id="1" name="PM_NoRefl" retID="371">
     <parameter id="370" />
    </function>
    <function id="2" name="PixelShaderNoReflection" retID="353">
     <parameter id="352" />
    </function>
    <function id="3" name="PixelMain" retID="336">
     <parameter id="335" />
    </function>
    <function id="4" name="VM_Para" retID="334">
     <parameter id="333" />
    </function>
    <function id="5" name="VM_NoPara" retID="332">
     <parameter id="331" />
    </function>
    <function id="6" name="VertexMain" retID="328">
     <parameter id="326" />
     <parameter id="327" />
    </function>
    <function id="7" name="HdrExpand" retID="298">
     <parameter id="297" />
    </function>
    <function id="8" name="DoShadowCar" retID="296">
     <parameter id="293" />
     <parameter id="294" />
     <parameter id="295" />
     <parameter id="0" />
    </function>
    <function id="9" name="DoShadowOptimized" retID="292">
     <parameter id="288" />
     <parameter id="289" />
     <parameter id="290" />
     <parameter id="291" />
     <parameter id="0" />
    </function>
    <function id="10" name="DoShadowPCF" retID="285">
     <parameter id="281" />
     <parameter id="282" />
     <parameter id="283" />
     <parameter id="284" />
     <parameter id="0" />
    </function>
    <function id="11" name="DoShadow" retID="278">
     <parameter id="275" />
     <parameter id="276" />
     <parameter id="277" />
     <parameter id="0" />
    </function>
    <function id="12" name="DoCSM3ShadowPCF" retID="264">
     <parameter id="263" />
    </function>
    <function id="13" name="SamplePCF" retID="259">
     <parameter id="257" />
     <parameter id="258" />
    </function>
    <function id="14" name="GetEdgeContrast" retID="253">
     <parameter id="252" />
    </function>
    <function id="15" name="Tex2DOffset" retID="243">
     <parameter id="240" />
     <parameter id="241" />
     <parameter id="242" />
    </function>
    <function id="16" name="VertexShadowTexOptimized" retID="239">
     <parameter id="235" />
     <parameter id="236" />
     <parameter id="237" />
     <parameter id="238" />
    </function>
    <function id="17" name="VertexShadowTex" retID="234">
     <parameter id="232" />
     <parameter id="233" />
    </function>
    <function id="18" name="CalculateShadowFade" retID="230">
     <parameter id="229" />
    </function>
    <function id="19" name="DepthSampleDepth" retID="217">
     <parameter id="215" />
     <parameter id="216" />
    </function>
    <function id="20" name="BasicAOLightingModelVertex" retID="204">
     <parameter id="200" />
     <parameter id="201" />
     <parameter id="202" />
     <parameter id="203" />
    </function>
    <function id="21" name="BasicAOLightingModelRoad" retID="193">
     <parameter id="186" />
     <parameter id="187" />
     <parameter id="188" />
     <parameter id="189" />
     <parameter id="190" />
     <parameter id="191" />
     <parameter id="192" />
    </function>
    <function id="22" name="BasicAOLightingModel" retID="179">
     <parameter id="173" />
     <parameter id="174" />
     <parameter id="175" />
     <parameter id="176" />
     <parameter id="177" />
     <parameter id="178" />
    </function>
    <function id="23" name="BasicLightingModel" retID="167">
     <parameter id="162" />
     <parameter id="163" />
     <parameter id="164" />
     <parameter id="165" />
     <parameter id="166" />
    </function>
    <function id="24" name="LightingModel" retID="156">
     <parameter id="149" />
     <parameter id="150" />
     <parameter id="151" />
     <parameter id="152" />
     <parameter id="153" />
     <parameter id="154" />
     <parameter id="155" />
    </function>
    <function id="25" name="BlinnSpec" retID="146">
     <parameter id="142" />
     <parameter id="143" />
     <parameter id="144" />
     <parameter id="145" />
    </function>
    <function id="26" name="BlinnSpecRoad" retID="136">
     <parameter id="131" />
     <parameter id="132" />
     <parameter id="133" />
     <parameter id="134" />
     <parameter id="135" />
    </function>
    <function id="27" name="GammaExpand" retID="130">
     <parameter id="129" />
    </function>
    <function id="28" name="GammaCompress" retID="128">
     <parameter id="127" />
    </function>
    <function id="29" name="DecodeRGBE8" retID="124">
     <parameter id="123" />
    </function>
    <function id="30" name="EncodeRGBE8" retID="119">
     <parameter id="118" />
    </function>
    <function id="31" name="DeCompressTextCoords" retID="117">
     <parameter id="116" />
    </function>
    <function id="32" name="DeCompressColourSpace" retID="115">
     <parameter id="114" />
    </function>
    <function id="33" name="CompressColourSpace" retID="113">
     <parameter id="112" />
    </function>
    <function id="34" name="world_position" retID="111">
     <parameter id="108" />
     <parameter id="109" />
     <parameter id="110" />
    </function>
    <function id="35" name="world_position" retID="107">
     <parameter id="105" />
     <parameter id="106" />
    </function>
    <function id="36" name="world_cartesian_position" retID="103">
     <parameter id="102" />
    </function>
    <function id="37" name="world_paraboloid_position" retID="99">
     <parameter id="98" />
    </function>
    <function id="38" name="EnvironmentMapLookup_Paraboloid_MipLevel" retID="92">
     <parameter id="88" />
     <parameter id="89" />
     <parameter id="90" />
     <parameter id="91" />
    </function>
    <function id="39" name="EnvironmentMapLookup_Paraboloid" retID="82">
     <parameter id="79" />
     <parameter id="80" />
     <parameter id="81" />
    </function>
    <function id="40" name="EnvironmentMapLookup_ParaboloidUVUV" retID="74">
     <parameter id="73" />
    </function>
    <function id="41" name="EnvironmentMapLookup_Paraboloid" retID="65">
     <parameter id="62" />
     <parameter id="63" />
     <parameter id="64" />
    </function>
    <function id="42" name="EnvironmentMapLookup_Cube" retID="60">
     <parameter id="57" />
     <parameter id="58" />
     <parameter id="59" />
    </function>
    <function id="43" name="EnvironmentMapLookup_Plane" retID="54">
     <parameter id="51" />
     <parameter id="52" />
     <parameter id="53" />
    </function>
    <function id="44" name="valueOf" retID="22">
     <parameter id="21" />
    </function>
    <function id="45" name="bias" retID="20">
     <parameter id="18" />
     <parameter id="19" />
    </function>
    <function id="46" name="NormalTransform" retID="16">
     <parameter id="14" />
     <parameter id="15" />
    </function>
    <function id="47" name="GetLocalEyePos" retID="13">
     <parameter id="12" />
    </function>
    <function id="48" name="GetLocalLightDir" retID="11">
     <parameter id="10" />
    </function>
   </funcInfo>
   <funcEntryExitInfo>
   </funcEntryExitInfo>
   <VfetchInfo>
    <vfetch Address="3" Register="2" DestSwizzle="xyzw" Semantic="0x00" End="false" />
    <vfetch Address="4" Register="4" DestSwizzle="x___" Semantic="0xa0" End="false" />
    <vfetch Address="5" Register="0" DestSwizzle="_xy_" Semantic="0x50" End="false" />
    <vfetch Address="6" Register="3" DestSwizzle="xyz1" Semantic="0x30" End="false" />
    <vfetch Address="7" Register="1" DestSwizzle="xyzw" Semantic="0x60" End="true" />
   </VfetchInfo>
   <InterpolatorInfo>
    <Interpolator Register="0" Semantic="0x50" Mask="xyz" />
    <Interpolator Register="1" Semantic="0x51" Mask="xyzw" />
    <Interpolator Register="2" Semantic="0x52" Mask="xyzw" />
    <Interpolator Register="3" Semantic="0x53" Mask="xyzw" />
    <Interpolator Register="4" Semantic="0x55" Mask="xyzw" />
   </InterpolatorInfo>
   <LiteralFloats>
    <Float Register="252" value0="0" value1="0" value2="0" value3="0" />
    <Float Register="253" value0="0" value1="0" value2="0" value3="0" />
    <Float Register="254" value0="0" value1="0" value2="0" value3="0" />
    <Float Register="255" value0="-1" value1="0" value2="0" value3="0" />
   </LiteralFloats>
   <LiteralInts>
   </LiteralInts>
   <LiteralBools>
   </LiteralBools>
  </shader>
 </shaders>
</shader-pdb>
